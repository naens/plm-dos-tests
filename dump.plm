/****p* plm-exercises/dump
 *  NAME
 *    dump -- print file in hexadecimal and ascii
 *  DESCRIPTION
 *    Prints a file, the name of which is given as command line argument, on
 *    the console.  Each line corresponds to 16 bytes, the first column
 *    contain the offset of the first byte of the line from the beginning of
 *    the file, the second column contains the hexadecimal values of each
 *    byte and the third column contains the the ASCII representation of
 *    printable characters.
 * 
 *    One screen is printed at a time if the file is large.  The user can
 *    navigate using ^S for previous, ^X, space or enter for next.  By typing
 *    'g', the user can enter the address to which to jump (the addresses are
 *    absolute offsets from the beginning of the file.
 *  USES
 *    cons and sys modules
 *****
 */
dump:
do;

$include (const.lit)
$include (cons.ext)
$include (sys.ext)
$include (fio.ext)
$include (str.ext)

    declare argc integer;
    declare pargv address;
    declare argv based pargv (*) address;

    declare line$len literally '16';
    declare line$num literally '16';

    declare f integer;
    declare n word;     /* number of butes read */
    declare a word;     /* position in the file */
    declare pos word;
    declare offset integer;
    declare buf(line$len) byte;
    declare key word;
    declare scrsz word; /* number of bytes on one screen */
    declare numlen word;


    /* prints n hex numbers separated by spaces, with padding to width */
    printhexline: procedure (pbuf, n, width);
        declare pbuf address;
        declare buf based pbuf (*) byte;
        declare n word;
        declare width integer;
        declare i integer;
        do i = 0 to width - 1;
            if i < integer(n) then
                call prhexbyte(buf(i));
            else
                call prstr(.('  ', 0));
            call prchr(' ');
            if i = 7 then
                call prchr(' ');
        end;
    end printhexline;


    /* prints n chars from buffer */
    printcharline: procedure (pbuf, n);
        declare pbuf address;
        declare buf based pbuf (*) byte;
        declare n word;
        declare i integer;
        declare c word;
        call prchr('|');
        do i = 0 to n - 1;
            c = buf(i);
            if c < ' ' or c > '~' then
                call prchr('.');
            else
                call prchr(c);
        end;
        call prchr('|');
    end printcharline;


    /* display single line from the buffer of the file being read */
    display$line: procedure (addr, pbuf, len, nline);
        declare addr word;
        declare pbuf address;
        declare len word;
        declare nline word;
        call prhexword(a);
        call prstr(.('    ', 0));
        call printhexline(.buf, n, line$len);
        call prchr(' ');
        call printcharline(.buf, n);
        call prcrlf;
    end display$line;


    /* read max len * num from file
     * display in lines of len, print num lines
     * return the number of bytes really printed
     */
    display$screen: procedure (f, addr, pbuf, len, num) word;
        declare f integer;
        declare addr word;
        declare pbuf address;
        declare len word;
        declare num word;
        declare total word;
        declare nline word;
        declare i word;
        total = 0;
        i = 0;
        do while i < len;
            nline = freadbuf(f, pbuf, len);
            call display$line(addr, pbuf, len, nline);
            total = total + nline;
            if nline < len then
                goto endloop;
            i = i + 1;
        end;
    endloop:
        return total;
    end display$screen;


    /* dump utility: print hex file and navigate it
     * Pseudocode:
     *   open file
     *   a=0
     *   loop
     *     c := read_and_display from file line$len*line$num
     *     a = a + c
     *     read command from keyboard
     *     if command is 'q' then
     *       exit from loop
     *     else
     *       if seek command then
     *         read seek line
     *         call parse_seek_and_go procedure    // with pos=a-c
     *       <repeat loop>
     *     end if
     *   end loop
     */

    call getargs(.argc, .pargv);
    if argc <> 2 then
    do;
        call println(.('Usage: dump <filename>', 0));
        goto exit;
    end;
    f = fopen(argv(1), true, false);
    if f <> -1 then
    do;
        call println(.('File open OK!', 0));
        call prhexword(fgetsize(f));
        call prcrlf;
        n = freadbuf(f, .buf, line$len);
        a = 0;
        scrsz = line$len * line$num;
        do while n > 0;
            if a > 0 and a mod scrsz = 0 then
            do;
                call readkey(.key);
                if key = 'u' then
                do;
                    if a >= 2 * scrsz then
                    do;
                        if fseekset(f, a - 2 * scrsz) <> -1 then
                        do;
                            a = a - 2 * scrsz;
                            n = freadbuf(f, .buf, line$len);
                        end;
                    end;
                    else
                        goto continue;
                end;
                if key = 'g' then   /* read from address from keyboard */
                do;
                    call prstr(.('a = ', 0));
                    call prhexword(a);
                    call prcrlf;
                    call prstr(.('go: ', 0));
                    call readln(.buf, line$len - 1);
                    call prstr(.('going: ', 0));
                    call println(.buf);
                    if buf(0) = '+' then
                    do;
                        offset = integer(xstr2word(.buf(1)));
                        if fseekcur(f, offset) = -1 then
                            goto endloop;
                        a = a + word(offset);
                    end;
                    else if buf(0) = '-' then
                    do;
                        offset = -integer(xstr2word(.buf(1)));
                        if fseekcur(f, offset) = -1 then
                            goto endloop;
                        a = a + word(offset);
                    end;
                    else if buf(0) = 'e' and buf(1) = '-' then
                    do;
                        pos = xstr2word(.buf(2));
                        if fseekend(f, pos) = -1 then
                            goto endloop;
                        a = fgetsize(f) - pos;
                    end;
                    else if buf(0) = 'b' and buf(1) = '+' then
                    do;
                        pos = xstr2word(.buf(2));
                        if fseekset(f, pos) = -1 then
                            goto endloop;
                        a = pos;
                    end;
                    else
                    do;
                        pos = xstr2word(.buf);
                        if fseekset(f, pos) = -1 then
                            goto endloop;
                        a = pos;
                    end;
                    call prstr(.('a = ', 0));
                    call prhexword(a);
                    call prcrlf;
                    n = freadbuf(f, .buf, line$len);
                end;
                /* TODO: g=go to address: read from kb
                 *       no prefix or b+value => absolute address
                 *       +/- prefix => relative address
                 *       e-value => relative to end
                 *       "e" = "e-0", "b" = "b+0" */
                else if key = 'q' then
                    goto close;
                call prcrlf;
            end;
            call prhexword(a);
            call prstr(.('    ', 0));
            call printhexline(.buf, n, line$len);
            call prchr(' ');
            call printcharline(.buf, n);
            call prcrlf;
            a = a + n;
            n = freadbuf(f, .buf, line$len);
continue:
        end;
        call prhexword(a);
        call prcrlf;
endloop:
close:
        call fclose(f);
    end;
    else
    do;
        call println(.('File open error', 0));
        goto exit;
    end;

exit:
    call term;

end;
