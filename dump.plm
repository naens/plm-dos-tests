/****p* plm-exercises/dump
 *  NAME
 *    dump -- print file in hexadecimal and ascii
 *  DESCRIPTION
 *    Prints a file, the name of which is given as command line argument, on
 *    the console.  Each line corresponds to 16 bytes, the first column
 *    contain the offset of the first byte of the line from the beginning of
 *    the file, the second column contains the hexadecimal values of each
 *    byte and the third column contains the the ASCII representation of
 *    printable characters.
 * 
 *    One screen is printed at a time if the file is large.  The user can
 *    navigate using ^S for previous, ^X, space or enter for next.  By typing
 *    'g', the user can enter the address to which to jump (the addresses are
 *    absolute offsets from the beginning of the file.
 *  USES
 *    cons and sys modules
 *****
 */
dump:
do;

$include (const.lit)
$include (cons.ext)
$include (sys.ext)
$include (fio.ext)
$include (str.ext)

    declare argc integer;
    declare pargv address;
    declare argv based pargv (*) address;

    declare line$len literally '16';
    declare line$num literally '16';

    declare f integer;
    declare n word;     /* number of butes read */
    declare a word;     /* position in the file */
    declare buf(line$len) byte;
    declare key word;
    declare scrsz word; /* number of bytes on one screen */
    declare numlen word;

    /* prints n hex numbers separated by spaces, with padding to width */
    printhexline: procedure (pbuf, n, width);
        declare pbuf address;
        declare buf based pbuf (*) byte;
        declare n word;
        declare width integer;
        declare i integer;
        do i = 0 to width - 1;
            if i < integer(n) then
                call prhexbyte(buf(i));
            else
                call prstr(.('  ', 0));
            call prchr(' ');
            if i = 7 then
                call prchr(' ');
        end;
    end printhexline;

    /* prints n chars from buffer */
    printcharline: procedure (pbuf, n);
        declare pbuf address;
        declare buf based pbuf (*) byte;
        declare n word;
        declare i integer;
        declare c word;
        call prchr('|');
        do i = 0 to n - 1;
            c = buf(i);
            if c < ' ' or c > '~' then
                call prchr('.');
            else
                call prchr(c);
        end;
        call prchr('|');
    end printcharline;

    goset: procedure (f, curpos, pos) word;
        declare f integer;
        declare curpos word;
        declare pos word;
        if fseekset(f, pos) = -1 then
            return curpos;
        return pos;
    end goset;

    gocur: procedure (f, curpos, offset) word;
        declare f integer;
        declare curpos word;
        declare offset integer;
        if fseekcur(f, offset) = -1 then
            return curpos;
        return curpos + word(offset);
    end gocur;

    goend: procedure (f, curpos, pos) word;
        declare f integer;
        declare curpos word;
        declare pos word;
        if fseekend(f, pos) = -1 then
            return curpos;
        return pos;
    end goend;

    call getargs(.argc, .pargv);
    if argc <> 2 then
    do;
        call println(.('Usage: dump <filename>', 0));
        goto exit;
    end;
    f = fopen(argv(1), true, false);
    if f <> -1 then
    do;
        call println(.('File open OK!', 0));
        call prhexword(fgetsize(f));
        call prcrlf;
        n = freadbuf(f, .buf, line$len);
        a = 0;
        scrsz = line$len * line$num;
        do while n > 0;
            if a > 0 and a mod scrsz = 0 then
            do;
                call readkey(.key);
                if key = 'u' then
                do;
                    if a >= 2 * scrsz then
                    do;
                        if fseekset(f, a - 2 * scrsz) <> -1 then
                        do;
                            a = a - 2 * scrsz;
                            n = freadbuf(f, .buf, line$len);
                        end;
                    end;
                    else
                        goto continue;
                end;
                if key = 'g' then   /* read from address from keyboard */
                do;
                    numlen = freadbuf(f, .buf, line$len - 1);
                    buf(numlen) = 0;
                    if buf(0) = '+' then
                    do;
                        a = gocur(f, a, integer(xstr2word(.buf)));
                    end;
                    else if buf(0) = '-' then
                    do;
                        a = gocur(f, a, -integer(xstr2word(.buf)));
                    end;
                    else if buf(0) = 'e' and buf(1) = '-' then
                    do;
                        a = goend(f, a, xstr2word(.buf(2)));
                    end;
                    else if buf(0) = 'b' and buf(1) = '+' then
                    do;
                        a = goset(f, a, xstr2word(.buf(2)));
                    end;
                    else
                    do;
                        a = goset(f, a, xstr2word(.buf(0)));
                    end;
                    n = freadbuf(f, .buf, line$len);
                end;
                /* TODO: g=go to address: read from kb
                 *       no prefix or b+value => absolute address
                 *       +/- prefix => relative address
                 *       e-value => relative to end
                 *       "e" = "e-0", "b" = "b+0" */
                else if key = 'q' then
                    goto close;
                call prcrlf;
            end;
            call prhexword(a);
            call prstr(.('    ', 0));
            call printhexline(.buf, n, line$len);
            call prchr(' ');
            call printcharline(.buf, n);
            call prcrlf;
            a = a + n;
            n = freadbuf(f, .buf, line$len);
continue:
        end;
        call prhexword(a);
        call prcrlf;
close:
        call fclose(f);
    end;
    else
    do;
        call println(.('File open error', 0));
        goto exit;
    end;

exit:
    call term;

end;
